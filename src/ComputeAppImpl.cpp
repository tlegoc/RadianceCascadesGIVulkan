//
// Created by theo on 02/10/2024.
//

#include <ComputeApp.h>
#include <ComputeAppConfig.h>
#include <Common.h>

#include <GLFW/glfw3.h>
#include <imgui.h>
#include <imgui_impl_vulkan.h>

#include <algorithm>

// Generated by shader compilation
// Avoid loading shaders through the filesystem, because i'm lazy
#include <PipelineBuilder.h>
#include <Shaders/DrawToSDFTexture.h>
#include <Shaders/FillTextureFloat4.h>

class ComputeAppImpl : public ComputeApp {
public:
    ComputeAppImpl() = default;

    // TODO FIX ALIGNMENT ISSUES
    struct ComputeDrawToSDFTexturePushConstant {
        uint16_t mousePosX;
        uint16_t mousePosY;
        uint16_t width;
        uint16_t height;
        uint8_t radius;
        uint8_t r;
        uint8_t g;
        uint8_t b;
    };

    // TODO FIX ALIGNMENT ISSUES
    struct FillTextureFloat4PushConstant {
        // uint16_t width;
        // uint16_t height;
        union {
            float value[4];
            struct {
                float r;
                float g;
                float b;
                float a;
            };
        };
    };

    void Init() override {
        VkImageCreateInfo imgCreateInfo = {VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO};
        imgCreateInfo.imageType = VK_IMAGE_TYPE_2D;
        imgCreateInfo.extent.width = WINDOW_WIDTH;
        imgCreateInfo.extent.height = WINDOW_HEIGHT;
        imgCreateInfo.extent.depth = 1;
        imgCreateInfo.mipLevels = 1;
        imgCreateInfo.arrayLayers = 1;
        imgCreateInfo.format = VK_FORMAT_R32G32B32A32_SFLOAT;

        imgCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
        imgCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        imgCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        imgCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;

        computeTargetImage = CreateImage(device, imgCreateInfo, allocator);
        currentComputeImageLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        PipelineBuilder pipelineBuilder(device);

        pipelineBuilder.AddShaderStage(DrawToSDFTexture, sizeof(DrawToSDFTexture), VK_SHADER_STAGE_COMPUTE_BIT);

        // Draw to SDF pipeline
        VkDescriptorSetLayoutBinding drawToSDFTextureDescriptorSetLayoutBinding{};
        drawToSDFTextureDescriptorSetLayoutBinding.binding = 0;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorCount = 1;
        drawToSDFTextureDescriptorSetLayoutBinding.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
        drawToSDFTextureDescriptorSetLayoutBinding.pImmutableSamplers = nullptr;
        pipelineBuilder.AddBinding(0, drawToSDFTextureDescriptorSetLayoutBinding);

        pipelineBuilder.SetPipelineType(Pipeline::COMPUTE);
        pipelineBuilder.SetPushConstantSize<ComputeDrawToSDFTexturePushConstant>(VK_SHADER_STAGE_COMPUTE_BIT);

        drawToSDFTexturePipeline = pipelineBuilder.Build();

        // Set descriptor set
        VkDescriptorImageInfo descriptorImageInfo{};
        descriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
        descriptorImageInfo.imageView = computeTargetImage.view;
        descriptorImageInfo.sampler = VK_NULL_HANDLE;
        drawToSDFTexturePipeline.WriteToDescriptorSet(0, 0, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, &descriptorImageInfo, nullptr);

        pipelineBuilder.Reset();

        pipelineBuilder.AddShaderStage(FillTextureFloat4, sizeof(FillTextureFloat4), VK_SHADER_STAGE_COMPUTE_BIT);

        // Draw to SDF pipeline
        VkDescriptorSetLayoutBinding fillTextureFloat4DescriptorSetLayoutBinding{};
        drawToSDFTextureDescriptorSetLayoutBinding.binding = 0;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorCount = 1;
        drawToSDFTextureDescriptorSetLayoutBinding.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
        drawToSDFTextureDescriptorSetLayoutBinding.pImmutableSamplers = nullptr;
        pipelineBuilder.AddBinding(0, drawToSDFTextureDescriptorSetLayoutBinding);

        pipelineBuilder.SetPipelineType(Pipeline::COMPUTE);
        pipelineBuilder.SetPushConstantSize<FillTextureFloat4PushConstant>(VK_SHADER_STAGE_COMPUTE_BIT);

        fillTextureFloat4Pipeline = pipelineBuilder.Build();

        fillTextureFloat4Pipeline.WriteToDescriptorSet(0, 0, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, &descriptorImageInfo, nullptr);

        VkSamplerCreateInfo imguiSamplerCreateInfo{};
        imguiSamplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        imguiSamplerCreateInfo.magFilter = VK_FILTER_LINEAR;
        imguiSamplerCreateInfo.minFilter = VK_FILTER_LINEAR;
        imguiSamplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        imguiSamplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        // outside image bounds just use border color
        imguiSamplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        imguiSamplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        imguiSamplerCreateInfo.minLod = -1000;
        imguiSamplerCreateInfo.maxLod = 1000;
        imguiSamplerCreateInfo.maxAnisotropy = 1.0f;

        vkCreateSampler(device, &imguiSamplerCreateInfo, nullptr, &imguiSampler);

        imguiImageDescriptorSet = ImGui_ImplVulkan_AddTexture(imguiSampler, computeTargetImage.view,
                                                              VK_IMAGE_LAYOUT_GENERAL);
    }

    void ComputeQueueInitCommands(VkCommandBuffer cmd) override {
        if (currentComputeImageLayout != VK_IMAGE_LAYOUT_GENERAL) {
            TransitionImage(cmd, computeTargetImage.image, currentComputeImageLayout, VK_IMAGE_LAYOUT_GENERAL);
            currentComputeImageLayout = VK_IMAGE_LAYOUT_GENERAL;
        }

        fillTextureFloat4Pipeline.Bind(cmd, VK_PIPELINE_BIND_POINT_COMPUTE);
        FillTextureFloat4PushConstant pushConstant{};
        // pushConstant.width = WINDOW_WIDTH;
        // pushConstant.height = WINDOW_HEIGHT;
        pushConstant.r = 0.0f;
        pushConstant.g = 0.0f;
        pushConstant.b = 0.0f;
        pushConstant.a = 1000000.0f;

        fillTextureFloat4Pipeline.SetPushConstant(cmd, VK_SHADER_STAGE_COMPUTE_BIT, &pushConstant);
        fillTextureFloat4Pipeline.Dispatch(cmd, WINDOW_WIDTH / 8, WINDOW_HEIGHT / 8, 1);
    }

    void Update(uint32_t frame) override {
        if (!ImGui::GetIO().WantCaptureMouse) {
            isLeftMouseButtonPressed = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS;
        } else {
            isLeftMouseButtonPressed = false;
        }

        // Update stuff here
        ImGui::Begin("Radiance Cascade settings");
        ImGui::SliderInt("Radius", &radius, 1, 256);
        ImGui::ColorPicker3("Pen color", (float*) &color);
        if (ImGui::CollapsingHeader("Debug")) {
            // Get max window width
            auto avail = ImGui::GetContentRegionAvail();
            ImGui::Image(imguiImageDescriptorSet, ImVec2(avail.x, avail.x * WINDOW_HEIGHT / WINDOW_WIDTH));
        }
        ImGui::End();
    }

    void ComputeQueueCommands(VkCommandBuffer cmd, VkImage swapchainImage, VkImageView swapchainImageView, VkExtent2D swapchainExtent) override {
        double xpos, ypos;
        glfwGetCursorPos(window, &xpos, &ypos);

        // Update push constants
        ComputeDrawToSDFTexturePushConstant pushConstant{};
        pushConstant.mousePosX = isLeftMouseButtonPressed ? xpos : -1;
        pushConstant.mousePosY = isLeftMouseButtonPressed ? ypos : -1;
        pushConstant.width = WINDOW_WIDTH;
        pushConstant.height = WINDOW_HEIGHT;
        pushConstant.radius = std::clamp(radius, 0, 255);
        pushConstant.r = std::clamp((int) (255 * color[0]), 0, 255);
        pushConstant.g = std::clamp((int) (255 * color[1]), 0, 255);
        pushConstant.b = std::clamp((int) (255 * color[2]), 0, 255);

        drawToSDFTexturePipeline.Bind(cmd, VK_PIPELINE_BIND_POINT_COMPUTE);
        drawToSDFTexturePipeline.SetPushConstant(cmd, VK_SHADER_STAGE_COMPUTE_BIT, &pushConstant);

        drawToSDFTexturePipeline.Dispatch(cmd, WINDOW_WIDTH / 8, WINDOW_HEIGHT / 8, 1);
    }

    void GraphicsQueueCommands(VkCommandBuffer cmd, VkImage swapchainImage, VkImageView swapchainImageView,
                               VkExtent2D swapchainExtent) override {
        VkImageBlit region{};
        region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        region.dstSubresource.layerCount = 1;
        region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        region.srcSubresource.layerCount = 1;
        region.srcOffsets[1].x = WINDOW_WIDTH;
        region.srcOffsets[1].y = WINDOW_HEIGHT;
        region.srcOffsets[1].z = 1;
        region.dstOffsets[1].x = swapchainExtent.width;
        region.dstOffsets[1].y = swapchainExtent.height;
        region.dstOffsets[1].z = 1;

        vkCmdBlitImage(cmd, computeTargetImage.image, VK_IMAGE_LAYOUT_GENERAL, swapchainImage, VK_IMAGE_LAYOUT_GENERAL,
                       1, &region, VK_FILTER_LINEAR);
    }

    void Cleanup() override {
        fillTextureFloat4Pipeline.Destroy();
        drawToSDFTexturePipeline.Destroy();
        ImGui_ImplVulkan_RemoveTexture(imguiImageDescriptorSet);
        vkDestroySampler(device, imguiSampler, nullptr);
        DestroyImage(device, allocator, computeTargetImage);
    }

private:
    Image computeTargetImage{};
    VkSampler imguiSampler{};
    VkImageLayout currentComputeImageLayout{};
    VkDescriptorSet imguiImageDescriptorSet{};
    Pipeline drawToSDFTexturePipeline{};
    Pipeline fillTextureFloat4Pipeline{};
    bool isLeftMouseButtonPressed = false;

    // Settings
    int radius = 10;
    float color[3] = {1.0f, 0.0f, 0.0f};
};

REGISTER_COMPUTE_APP(ComputeAppImpl)
