//
// Created by theo on 02/10/2024.
//

#include <ComputeApp.h>
#include <ComputeAppConfig.h>
#include <Common.h>

#include <GLFW/glfw3.h>
#include <imgui.h>
#include <imgui_impl_vulkan.h>

#include <algorithm>

// Generated by shader compilation
// Avoid loading shaders through the filesystem, because i'm lazy
#include <Shaders/DrawToSDFTexture.h>

class ComputeAppImpl : public ComputeApp {
public:
    ComputeAppImpl() = default;

    struct ComputeDrawToSDFTexturePushConstant {
        uint16_t mousePosX;
        uint16_t mousePosY;
        uint16_t width;
        uint16_t height;
        uint8_t radius;
        uint8_t r;
        uint8_t g;
        uint8_t b;
    };

    void Init() override {
        VkImageCreateInfo imgCreateInfo = {VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO};
        imgCreateInfo.imageType = VK_IMAGE_TYPE_2D;
        imgCreateInfo.extent.width = WINDOW_WIDTH;
        imgCreateInfo.extent.height = WINDOW_HEIGHT;
        imgCreateInfo.extent.depth = 1;
        imgCreateInfo.mipLevels = 1;
        imgCreateInfo.arrayLayers = 1;
        imgCreateInfo.format = VK_FORMAT_R32G32B32A32_SFLOAT;

        imgCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
        imgCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        imgCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
        imgCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;

        computeTargetImage = CreateImage(device, imgCreateInfo, allocator);
        currentComputeImageLayout = VK_IMAGE_LAYOUT_UNDEFINED;

        // Draw to SDF pipeline
        // I have to create a wrapper around this
        VkDescriptorSetLayoutBinding drawToSDFTextureDescriptorSetLayoutBinding{};
        drawToSDFTextureDescriptorSetLayoutBinding.binding = 0;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        drawToSDFTextureDescriptorSetLayoutBinding.descriptorCount = 1;
        drawToSDFTextureDescriptorSetLayoutBinding.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
        drawToSDFTextureDescriptorSetLayoutBinding.pImmutableSamplers = nullptr;

        VkDescriptorSetLayoutCreateInfo drawToSDFTextureDescriptorSetLayoutCreateInfo{};
        drawToSDFTextureDescriptorSetLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
        drawToSDFTextureDescriptorSetLayoutCreateInfo.bindingCount = 1;
        drawToSDFTextureDescriptorSetLayoutCreateInfo.pBindings = &drawToSDFTextureDescriptorSetLayoutBinding;
        drawToSDFTextureDescriptorSetLayoutCreateInfo.flags = 0;

        vkCreateDescriptorSetLayout(device, &drawToSDFTextureDescriptorSetLayoutCreateInfo, nullptr,
                                    &drawToSDFTextureDescriptorSetLayout);

        VkDescriptorPoolSize drawToSDFTextureDescriptorPoolSize{};
        drawToSDFTextureDescriptorPoolSize.type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        drawToSDFTextureDescriptorPoolSize.descriptorCount = 1;

        VkDescriptorPoolCreateInfo drawToSDFTextureDescriptorPoolCreateInfo{};
        drawToSDFTextureDescriptorPoolCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        drawToSDFTextureDescriptorPoolCreateInfo.poolSizeCount = 1;
        drawToSDFTextureDescriptorPoolCreateInfo.pPoolSizes = &drawToSDFTextureDescriptorPoolSize;
        drawToSDFTextureDescriptorPoolCreateInfo.maxSets = 1;

        vkCreateDescriptorPool(device, &drawToSDFTextureDescriptorPoolCreateInfo, nullptr,
                               &drawToSDFTextureDescriptorPool);

        VkDescriptorSetAllocateInfo drawToSDFTextureDescriptorSetAllocateInfo{};
        drawToSDFTextureDescriptorSetAllocateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
        drawToSDFTextureDescriptorSetAllocateInfo.descriptorPool = drawToSDFTextureDescriptorPool;
        drawToSDFTextureDescriptorSetAllocateInfo.descriptorSetCount = 1;
        drawToSDFTextureDescriptorSetAllocateInfo.pSetLayouts = &drawToSDFTextureDescriptorSetLayout;

        vkAllocateDescriptorSets(device, &drawToSDFTextureDescriptorSetAllocateInfo, &drawToSDFTextureDescriptorSet);

        VkPushConstantRange drawToSDFTexturePushConstantRange{};
        drawToSDFTexturePushConstantRange.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
        drawToSDFTexturePushConstantRange.offset = 0;
        drawToSDFTexturePushConstantRange.size = sizeof(ComputeDrawToSDFTexturePushConstant);

        VkPipelineLayoutCreateInfo drawToSDFTextureLayoutCreateInfo{};
        drawToSDFTextureLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        drawToSDFTextureLayoutCreateInfo.setLayoutCount = 1;
        drawToSDFTextureLayoutCreateInfo.pSetLayouts = &drawToSDFTextureDescriptorSetLayout;
        drawToSDFTextureLayoutCreateInfo.pushConstantRangeCount = 1;
        drawToSDFTextureLayoutCreateInfo.pPushConstantRanges = &drawToSDFTexturePushConstantRange;
        drawToSDFTextureLayoutCreateInfo.flags = 0;

        vkCreatePipelineLayout(device, &drawToSDFTextureLayoutCreateInfo, nullptr, &drawToSDFTextureLayout);

        VkPipelineShaderStageCreateInfo shaderStages{};
        shaderStages.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        shaderStages.stage = VK_SHADER_STAGE_COMPUTE_BIT;
        shaderStages.module = CreateShaderModule(device, DrawToSDFTexture, sizeof(DrawToSDFTexture));
        shaderStages.flags = 0;
        shaderStages.pName = "main";

        VkComputePipelineCreateInfo drawToSDFTexturePipelineCreateInfo{};
        drawToSDFTexturePipelineCreateInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
        drawToSDFTexturePipelineCreateInfo.stage = shaderStages;
        drawToSDFTexturePipelineCreateInfo.layout = drawToSDFTextureLayout;

        vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &drawToSDFTexturePipelineCreateInfo, nullptr,
                                 &drawToSDFTexturePipeline);

        vkDestroyShaderModule(device, shaderStages.module, nullptr);

        // Set descriptor set
        VkDescriptorImageInfo drawToSDFTextureDescriptorImageInfo{};
        drawToSDFTextureDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
        drawToSDFTextureDescriptorImageInfo.imageView = computeTargetImage.view;
        drawToSDFTextureDescriptorImageInfo.sampler = VK_NULL_HANDLE;

        // Update descriptor set
        VkWriteDescriptorSet drawToSDFTextureWriteDescriptorSet{};
        drawToSDFTextureWriteDescriptorSet.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
        drawToSDFTextureWriteDescriptorSet.dstSet = drawToSDFTextureDescriptorSet;
        drawToSDFTextureWriteDescriptorSet.dstBinding = 0;
        drawToSDFTextureWriteDescriptorSet.dstArrayElement = 0;
        drawToSDFTextureWriteDescriptorSet.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
        drawToSDFTextureWriteDescriptorSet.descriptorCount = 1;
        drawToSDFTextureWriteDescriptorSet.pImageInfo = &drawToSDFTextureDescriptorImageInfo;

        vkUpdateDescriptorSets(device, 1, &drawToSDFTextureWriteDescriptorSet, 0, nullptr);

        VkSamplerCreateInfo imguiSamplerCreateInfo{};
        imguiSamplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        imguiSamplerCreateInfo.magFilter = VK_FILTER_LINEAR;
        imguiSamplerCreateInfo.minFilter = VK_FILTER_LINEAR;
        imguiSamplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        imguiSamplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        // outside image bounds just use border color
        imguiSamplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        imguiSamplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        imguiSamplerCreateInfo.minLod = -1000;
        imguiSamplerCreateInfo.maxLod = 1000;
        imguiSamplerCreateInfo.maxAnisotropy = 1.0f;

        vkCreateSampler(device, &imguiSamplerCreateInfo, nullptr, &imguiSampler);

        imguiImageDescriptorSet = ImGui_ImplVulkan_AddTexture(imguiSampler, computeTargetImage.view,
                                                              VK_IMAGE_LAYOUT_GENERAL);
    }

    void ComputeQueuInitCommands(VkCommandBuffer cmd) override {

    }

    void Update(uint32_t frame) override {
        if (!ImGui::GetIO().WantCaptureMouse) {
            isLeftMouseButtonPressed = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS;
        } else {
            isLeftMouseButtonPressed = false;
        }

        // Update stuff here
        ImGui::Begin("Radiance Cascade settings");
        ImGui::SliderInt("Radius", &radius, 1, 256);
        ImGui::ColorPicker3("Pen color", (float*) &color);
        if (ImGui::CollapsingHeader("Debug")) {
            // Get max window width
            auto avail = ImGui::GetContentRegionAvail();
            ImGui::Image(imguiImageDescriptorSet, ImVec2(avail.x, avail.x * WINDOW_HEIGHT / WINDOW_WIDTH));
        }
        ImGui::End();
    }

    void ComputeQueueCommands(VkCommandBuffer cmd, VkImage swapchainImage, VkImageView swapchainImageView, VkExtent2D swapchainExtent) override {
        double xpos, ypos;
        glfwGetCursorPos(window, &xpos, &ypos);

        if (currentComputeImageLayout != VK_IMAGE_LAYOUT_GENERAL) {
            TransitionImage(cmd, computeTargetImage.image, currentComputeImageLayout, VK_IMAGE_LAYOUT_GENERAL);
            currentComputeImageLayout = VK_IMAGE_LAYOUT_GENERAL;
        }

        // Update push constants
        ComputeDrawToSDFTexturePushConstant pushConstant{};
        pushConstant.mousePosX = isLeftMouseButtonPressed ? xpos : -1;
        pushConstant.mousePosY = isLeftMouseButtonPressed ? ypos : -1;
        pushConstant.width = WINDOW_WIDTH;
        pushConstant.height = WINDOW_HEIGHT;
        pushConstant.radius = std::clamp(radius, 0, 255);
        pushConstant.r = std::clamp((int) (255 * color[0]), 0, 255);
        pushConstant.g = std::clamp((int) (255 * color[1]), 0, 255);
        pushConstant.b = std::clamp((int) (255 * color[2]), 0, 255);

        vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, drawToSDFTexturePipeline);
        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, drawToSDFTextureLayout, 0, 1,
                                &drawToSDFTextureDescriptorSet, 0, nullptr);
        vkCmdPushConstants(cmd, drawToSDFTextureLayout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(ComputeDrawToSDFTexturePushConstant),
                           &pushConstant);

        vkCmdDispatch(cmd, WINDOW_WIDTH / 8, WINDOW_HEIGHT / 8, 1);
    }

    void GraphicsQueueCommands(VkCommandBuffer cmd, VkImage swapchainImage, VkImageView swapchainImageView,
                               VkExtent2D swapchainExtent) override {
        VkImageBlit region{};
        region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        region.dstSubresource.layerCount = 1;
        region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        region.srcSubresource.layerCount = 1;
        region.srcOffsets[1].x = WINDOW_WIDTH;
        region.srcOffsets[1].y = WINDOW_HEIGHT;
        region.srcOffsets[1].z = 1;
        region.dstOffsets[1].x = swapchainExtent.width;
        region.dstOffsets[1].y = swapchainExtent.height;
        region.dstOffsets[1].z = 1;

        vkCmdBlitImage(cmd, computeTargetImage.image, VK_IMAGE_LAYOUT_GENERAL, swapchainImage, VK_IMAGE_LAYOUT_GENERAL,
                       1, &region, VK_FILTER_LINEAR);
    }

    void Cleanup() override {
        ImGui_ImplVulkan_RemoveTexture(imguiImageDescriptorSet);
        vkDestroySampler(device, imguiSampler, nullptr);
        vkDestroyPipelineLayout(device, drawToSDFTextureLayout, nullptr);
        vkDestroyPipeline(device, drawToSDFTexturePipeline, nullptr);
        vkDestroyDescriptorPool(device, drawToSDFTextureDescriptorPool, nullptr);
        vkDestroyDescriptorSetLayout(device, drawToSDFTextureDescriptorSetLayout, nullptr);
        DestroyImage(device, allocator, computeTargetImage);
    }

private:
    Image computeTargetImage{};
    VkSampler imguiSampler{};
    VkDescriptorSet imguiImageDescriptorSet{};
    VkImageLayout currentComputeImageLayout{};
    VkDescriptorSet drawToSDFTextureDescriptorSet{};
    VkPipeline drawToSDFTexturePipeline{};
    VkPipelineLayout drawToSDFTextureLayout{};
    VkDescriptorPool drawToSDFTextureDescriptorPool{};
    VkDescriptorSetLayout drawToSDFTextureDescriptorSetLayout{};
    bool isLeftMouseButtonPressed = false;

    // Settings
    int radius = 10;
    float color[3] = {1.0f, 0.0f, 0.0f};
};

REGISTER_COMPUTE_APP(ComputeAppImpl)
